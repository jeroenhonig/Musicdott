/**
 * POS CSV Import System Schema
 *
 * Lossless, embed-first import system for POS_Notatie.csv and POS_Songs.csv
 * - Notation parser for structured drum events
 * - Song ↔ Notation mapping layer
 * - Generator-ready drumblock system
 */

import { pgTable, serial, integer, text, timestamp, boolean, jsonb } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
// Note: Foreign key references to schools table are omitted to avoid circular imports
// The schoolId field is still enforced at the application level

// ============================================
// 1. Notations table (from POS_Notatie.csv)
// ============================================
export const notations = pgTable("notations", {
  id: serial("id").primaryKey(),
  schoolId: integer("school_id").notNull(),

  // Original POS fields (lossless - ALWAYS preserved)
  posNoid: integer("pos_noid"),                      // Original notation ID
  posCategorie: text("pos_categorie"),               // Original category
  posHoofdstuk: text("pos_hoofdstuk"),               // Chapter
  posVolgnummer: integer("pos_volgnummer"),          // Sequence number
  posNotatie: text("pos_notatie"),                   // ALWAYS preserved - raw notation string
  posOpmerkingen: text("pos_opmerkingen"),           // Notes/remarks
  posAangemaakt: timestamp("pos_aangemaakt"),        // Created date
  posGewijzigd: timestamp("pos_gewijzigd"),          // Modified date
  posMsid: integer("pos_msid"),                      // Original MS ID
  posGewijzigddoor: text("pos_gewijzigddoor"),       // Modified by

  // Normalized fields (for application use)
  title: text("title").notNull(),
  category: text("category"),
  orderNumber: integer("order_number"),

  // Parsed notation (JSON) - generated by notation parser
  parsedNotation: text("parsed_notation"),           // JSON with events
  parserStatus: text("parser_status"),               // "ok" | "partial" | "failed"

  // Embed/media JSON storage (lossless)
  mediaJsonb: jsonb("media_jsonb"),
  rawJsonb: jsonb("raw_jsonb"),

  // Metadata
  importBatchId: text("import_batch_id"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  isActive: boolean("is_active").default(true),
});

// ============================================
// 2. POS Songs table (from POS_Songs.csv)
// ============================================
export const posSongs = pgTable("pos_songs", {
  id: serial("id").primaryKey(),
  schoolId: integer("school_id").notNull(),

  // Original POS fields (lossless - ALWAYS preserved)
  posSoid: integer("pos_soid"),                      // Original song ID
  posArtiest: text("pos_artiest"),                   // Artist name
  posTitel: text("pos_titel"),                       // Song title
  posBpm: integer("pos_bpm"),                        // BPM
  posLengte: text("pos_lengte"),                     // Length/duration
  posGenre: text("pos_genre"),                       // Genre
  posYoutube: text("pos_youtube"),                   // Raw iframe HTML - DO NOT CLEAN
  posSpotify: text("pos_spotify"),                   // Spotify URL/embed
  posAppleMusic: text("pos_apple_music"),            // Apple Music URL
  posLyrics: text("pos_lyrics"),                     // Lyrics text
  posUitlegtekst: text("pos_uitleg_tekst"),          // Explanation text
  posUitlegvideo: text("pos_uitleg_video"),          // Explanation video
  posAangemaakt: timestamp("pos_aangemaakt"),        // Created date
  posGewijzigd: timestamp("pos_gewijzigd"),          // Modified date
  posMsid: integer("pos_msid"),                      // Original MS ID
  posGewijzigddoor: text("pos_gewijzigddoor"),       // Modified by

  // Normalized embeds (JSON) - extracted from raw HTML/URLs
  embeds: text("embeds"),                            // { youtube: {...}, spotify: {...} }
  lyricsClean: text("lyrics_clean"),                 // UTF-8 normalized lyrics

  // Embed/media JSON storage (lossless)
  embedsJsonb: jsonb("embeds_jsonb"),
  rawJsonb: jsonb("raw_jsonb"),

  // Link to main songs table (optional - for integration)
  linkedSongId: integer("linked_song_id"),

  // Metadata
  importBatchId: text("import_batch_id"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// ============================================
// 3. Song ↔ Notation mappings
// ============================================
export const songNotationMappings = pgTable("song_notation_mappings", {
  id: serial("id").primaryKey(),
  schoolId: integer("school_id").notNull(),

  songId: integer("song_id"),                        // Reference to posSongs
  notationId: integer("notation_id"),                // Reference to notations

  // Match metadata
  bpmDelta: integer("bpm_delta"),                    // BPM difference between song and notation
  feel: text("feel"),                                // "straight" | "shuffle" | "triplet"
  difficulty: integer("difficulty"),                 // 1-5 difficulty scale

  // Usage context
  section: text("section"),                          // "verse" | "chorus" | "fill" | "groove"
  isLoop: boolean("is_loop").default(true),
  notes: text("notes"),                              // Additional notes

  // Mapping type
  mappingType: text("mapping_type"),                 // "manual" | "rule_based" | "suggested"

  createdAt: timestamp("created_at").defaultNow(),
});

// ============================================
// 4. Drumblocks (extracted from notations)
// ============================================
export const drumblocks = pgTable("drumblocks", {
  id: serial("id").primaryKey(),
  schoolId: integer("school_id").notNull(),

  blockId: text("block_id").notNull(),               // "B12", "B7", etc.
  lengthSteps: integer("length_steps").notNull(),    // Number of steps in the block
  events: text("events").notNull(),                  // JSON array of events

  // Classification
  tags: text("tags"),                                // JSON array: ["fill", "linear", "right-hand-lead"]
  difficulty: integer("difficulty"),                 // 1-5 difficulty scale

  // Source tracking
  sourceNotationId: integer("source_notation_id"),   // Reference to notations

  createdAt: timestamp("created_at").defaultNow(),
});

// ============================================
// 5. Import logs
// ============================================
export const posImportLogs = pgTable("pos_import_logs", {
  id: serial("id").primaryKey(),
  schoolId: integer("school_id").notNull(),
  userId: integer("user_id").notNull(),
  batchId: text("batch_id").notNull(),
  fileType: text("file_type").notNull(),             // "notations" | "songs"
  fileName: text("file_name").notNull(),
  totalRows: integer("total_rows"),
  imported: integer("imported"),
  skipped: integer("skipped"),
  errors: integer("errors"),
  errorDetails: text("error_details"),               // JSON array of error details
  status: text("status").default("processing"),      // "processing" | "completed" | "failed"
  startedAt: timestamp("started_at").defaultNow(),
  completedAt: timestamp("completed_at"),
});

// ============================================
// Insert Schemas
// ============================================
export const insertNotationSchema = createInsertSchema(notations).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertPosSongSchema = createInsertSchema(posSongs).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertSongNotationMappingSchema = createInsertSchema(songNotationMappings).omit({
  id: true,
  createdAt: true,
});

export const insertDrumblockSchema = createInsertSchema(drumblocks).omit({
  id: true,
  createdAt: true,
});

export const insertPosImportLogSchema = createInsertSchema(posImportLogs).omit({
  id: true,
  startedAt: true,
  completedAt: true,
});

// ============================================
// Types
// ============================================
export type Notation = typeof notations.$inferSelect;
export type InsertNotation = z.infer<typeof insertNotationSchema>;

export type PosSong = typeof posSongs.$inferSelect;
export type InsertPosSong = z.infer<typeof insertPosSongSchema>;

export type SongNotationMapping = typeof songNotationMappings.$inferSelect;
export type InsertSongNotationMapping = z.infer<typeof insertSongNotationMappingSchema>;

export type Drumblock = typeof drumblocks.$inferSelect;
export type InsertDrumblock = z.infer<typeof insertDrumblockSchema>;

export type PosImportLog = typeof posImportLogs.$inferSelect;
export type InsertPosImportLog = z.infer<typeof insertPosImportLogSchema>;

// ============================================
// Parsed Notation Types (for parser output)
// ============================================

// Event in the parsed notation
export interface NotationEvent {
  step: number;                                      // Grid step position
  limb: "R" | "L" | "K" | "F";                       // Right hand, Left hand, Kick, Foot (hi-hat)
  instrument: "snare" | "kick" | "hihat" | "tom" | "cymbal" | "ride" | "crash" | "floor_tom" | "high_tom";
  velocity: number;                                  // 0-1, default 0.7
  accent: boolean;                                   // Accented note
}

// Full parsed notation structure
export interface ParsedNotation {
  status: "ok" | "partial" | "failed";

  time_signature: { beats: number; unit: number };
  tempo: number;
  division: number;                                  // Steps per beat (e.g., 16 for 16th notes)
  measures: number;

  grid: {
    steps_per_measure: number;
    total_steps: number;
  };

  events: NotationEvent[];

  meta: {
    parser_version: string;
    errors: string[];
    warnings: string[];
    raw_notation?: string;                           // Original notation string
  };
}

// ============================================
// Embed Types (for embed extraction)
// ============================================
export interface Embed {
  type: "video" | "audio" | "notation" | "pdf";
  provider: string;                                  // "youtube" | "spotify" | "apple_music" | "soundcloud"
  embed_url: string | null;                          // Extracted embed URL
  video_id?: string;                                 // YouTube video ID
  raw: string | null;                                // Original raw HTML/URL
  fallback?: string;                                 // Fallback message
}

export interface SongEmbeds {
  youtube?: Embed;
  spotify?: Embed;
  apple_music?: Embed;
}

// ============================================
// Generator Types
// ============================================

// Drumblock structure for generator
export interface DrumblockData {
  block_id: string;                                  // "B12"
  length_steps: number;                              // 4
  events: NotationEvent[];
  tags: string[];                                    // ["fill", "linear", "right-hand-lead"]
  difficulty: number;                                // 1-5
  source_notation_id?: number;
}

// Generator constraints
export interface GeneratorConstraints {
  maxDifficulty?: number;
  limbBalance?: "even" | "right-lead" | "left-lead";
  density?: "sparse" | "medium" | "dense";
  tempoRange?: { min: number; max: number };
  tags?: string[];
  excludeTags?: string[];
  blockCount?: number;
}

// Generator output
export interface GeneratedPattern {
  blocks: string[];                                  // ["B12", "B7", "B3"]
  total_steps: number;
  renderable_notation: ParsedNotation;
  playable: boolean;
  constraints_applied: GeneratorConstraints;
}

// ============================================
// Batch Result Type
// ============================================
export interface BatchResult {
  inserted: number;
  skipped: number;
  errors: Array<{ row: number; error: string }>;
}
